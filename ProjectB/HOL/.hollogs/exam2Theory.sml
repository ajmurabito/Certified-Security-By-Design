/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:88: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:125: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:162: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:250: warning: Pattern is not exhaustive.
Found near val [prop_type, name_type, integ_type, ...] = snd f1_type_parts
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1245: warning: Matches are not exhaustive. Found near fn [th1, th2] => ACL_CONJ th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1276: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ1 disj2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1304: warning: Matches are not exhaustive. Found near fn [th] => ACL_DISJ2 disj1 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1336: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1337: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1340: warning: Matches are not exhaustive. Found near fn [th] => ACL_MP th2 th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1374: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1408: warning: Matches are not exhaustive. Found near fn [th] => AND_SAYS_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1440: warning: Matches are not exhaustive. Found near fn [th1, th2] => CONTROLS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1473: warning: Matches are not exhaustive. Found near fn [th1, th2] => DC th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1506: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMI_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1541: warning: Matches are not exhaustive. Found near fn [th1, th2] => DOMS_TRANS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1575: warning: Matches are not exhaustive. Found near fn [th1, th2] => HS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1601: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1602: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1604: warning: Pattern is not exhaustive.
Found near val (_, [proptype, ...]) = dest_type formType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1643: warning: Matches are not exhaustive.
Found near fn [th1, th2, th3] => IL_DOMI th2 th1 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1679: warning: Matches are not exhaustive.
Found near fn [th1, th2] => MONO_SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1709: warning: Pattern is not exhaustive.
Found near val (_, [kripketype, ...]) = dest_type tupleType
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1710: warning: Pattern is not exhaustive.
Found near val (_, [_, ...]) = dest_type kripketype
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1745: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_LR th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1776: warning: Matches are not exhaustive. Found near fn [th] => QUOTING_RL th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1810: warning: Matches are not exhaustive. Found near fn [th1, th2, th3] => REPS th1 th2 th3
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1842: warning: Matches are not exhaustive. Found near fn [th1, th2] => REP_SAYS th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1869: warning: Matches are not exhaustive. Found near fn [th] => SAYS princ th
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1901: warning: Matches are not exhaustive. Found near fn [th1, th2] => SPEAKS_FOR th1 th2
/home/csbd/Documents/RESEARCH/HOL/ACL/acl_infRules.sml:1934: warning: Matches are not exhaustive.
Found near fn [th1, th2] => TRANS_SPEAKS_FOR th1 th2
<<HOL message: Created theory "exam2">>
Saved theorem _____ "num2roles_roles2num"
Saved theorem _____ "roles2num_num2roles"
Saved theorem _____ "num2roles_11"
Saved theorem _____ "roles2num_11"
Saved theorem _____ "num2roles_ONTO"
Saved theorem _____ "roles2num_ONTO"
Saved theorem _____ "num2roles_thm"
Saved theorem _____ "roles2num_thm"
Saved theorem _____ "roles_EQ_roles"
Saved theorem _____ "roles_case_def"
Saved theorem _____ "datatype_roles"
Saved theorem _____ "roles_case_cong"
Saved theorem _____ "roles_nchotomy"
Saved theorem _____ "roles_Axiom"
Saved theorem _____ "roles_induction"
<<HOL message: Defined type: "roles">>
Saved theorem _____ "num2people_people2num"
Saved theorem _____ "people2num_num2people"
Saved theorem _____ "num2people_11"
Saved theorem _____ "people2num_11"
Saved theorem _____ "num2people_ONTO"
Saved theorem _____ "people2num_ONTO"
Saved theorem _____ "num2people_thm"
Saved theorem _____ "people2num_thm"
Saved theorem _____ "people_EQ_people"
Saved theorem _____ "people_case_def"
Saved theorem _____ "datatype_people"
Saved theorem _____ "people_case_cong"
Saved theorem _____ "people_nchotomy"
Saved theorem _____ "people_Axiom"
Saved theorem _____ "people_induction"
<<HOL message: Defined type: "people">>
Saved theorem _____ "datatype_passPrinc"
Saved theorem _____ "passPrinc_11"
Saved theorem _____ "passPrinc_case_cong"
Saved theorem _____ "passPrinc_nchotomy"
Saved theorem _____ "passPrinc_Axiom"
Saved theorem _____ "passPrinc_induction"
<<HOL message: Defined type: "passPrinc">>
Saved theorem _____ "datatype_principals"
Saved theorem _____ "principals_11"
Saved theorem _____ "principals_distinct"
Saved theorem _____ "principals_case_cong"
Saved theorem _____ "principals_nchotomy"
Saved theorem _____ "principals_Axiom"
Saved theorem _____ "principals_induction"
<<HOL message: Defined type: "principals">>
Saved theorem _____ "datatype_accounts"
Saved theorem _____ "accounts_11"
Saved theorem _____ "accounts_case_cong"
Saved theorem _____ "accounts_nchotomy"
Saved theorem _____ "accounts_Axiom"
Saved theorem _____ "accounts_induction"
<<HOL message: Defined type: "accounts">>
Saved theorem _____ "num2people2_people22num"
Saved theorem _____ "people22num_num2people2"
Saved theorem _____ "num2people2_11"
Saved theorem _____ "people22num_11"
Saved theorem _____ "num2people2_ONTO"
Saved theorem _____ "people22num_ONTO"
Saved theorem _____ "num2people2_thm"
Saved theorem _____ "people22num_thm"
Saved theorem _____ "people2_EQ_people2"
Saved theorem _____ "people2_case_def"
Saved theorem _____ "datatype_people2"
Saved theorem _____ "people2_case_cong"
Saved theorem _____ "people2_nchotomy"
Saved theorem _____ "people2_Axiom"
Saved theorem _____ "people2_induction"
<<HOL message: Defined type: "people2">>
Saved theorem _____ "num2roles2_roles22num"
Saved theorem _____ "roles22num_num2roles2"
Saved theorem _____ "num2roles2_11"
Saved theorem _____ "roles22num_11"
Saved theorem _____ "num2roles2_ONTO"
Saved theorem _____ "roles22num_ONTO"
Saved theorem _____ "num2roles2_thm"
Saved theorem _____ "roles22num_thm"
Saved theorem _____ "roles2_EQ_roles2"
Saved theorem _____ "roles2_case_def"
Saved theorem _____ "datatype_roles2"
Saved theorem _____ "roles2_case_cong"
Saved theorem _____ "roles2_nchotomy"
Saved theorem _____ "roles2_Axiom"
Saved theorem _____ "roles2_induction"
<<HOL message: Defined type: "roles2">>
Saved theorem _____ "datatype_pinIdPrinc"
Saved theorem _____ "pinIdPrinc_11"
Saved theorem _____ "pinIdPrinc_case_cong"
Saved theorem _____ "pinIdPrinc_nchotomy"
Saved theorem _____ "pinIdPrinc_Axiom"
Saved theorem _____ "pinIdPrinc_induction"
<<HOL message: Defined type: "pinIdPrinc">>
Saved theorem _____ "datatype_RichesPrincipals"
Saved theorem _____ "RichesPrincipals_11"
Saved theorem _____ "RichesPrincipals_distinct"
Saved theorem _____ "RichesPrincipals_case_cong"
Saved theorem _____ "RichesPrincipals_nchotomy"
Saved theorem _____ "RichesPrincipals_Axiom"
Saved theorem _____ "RichesPrincipals_induction"
<<HOL message: Defined type: "RichesPrincipals">>
Saved theorem _____ "datatype_richAccts"
Saved theorem _____ "richAccts_11"
Saved theorem _____ "richAccts_case_cong"
Saved theorem _____ "richAccts_nchotomy"
Saved theorem _____ "richAccts_Axiom"
Saved theorem _____ "richAccts_induction"
<<HOL message: Defined type: "richAccts">>
Saved theorem _____ "exam2_1_thm"
Saved theorem _____ "exam2_2_thm"
Theory: exam2

Parents:
    aclDrules

Type constants:
    RichesPrincipals 0
    accounts 0
    passPrinc 0
    people 0
    people2 0
    pinIdPrinc 0
    principals 0
    richAccts 0
    roles 0
    roles2 0

Term constants:
    AC                      :people -> accounts
    BN                      :num -> RichesPrincipals
    BankOfRiches            :roles2
    Client                  :people2 -> pinIdPrinc
    Don                     :people2
    ID                      :pinIdPrinc -> RichesPrincipals
    KennedyCenter           :roles
    Mary                    :people
    PIN                     :pinIdPrinc -> RichesPrincipals
    PR                      :passPrinc -> principals
    PR2                     :pinIdPrinc -> RichesPrincipals
    Pass                    :passPrinc -> principals
    RAC                     :pinIdPrinc -> richAccts
    RichesPrincipals_CASE   :RichesPrincipals ->
                             (pinIdPrinc -> α) ->
                             (pinIdPrinc -> α) ->
                             (pinIdPrinc -> α) ->
                             (roles2 -> α) -> (num -> α) -> α
    RichesPrincipals_size   :RichesPrincipals -> num
    Role                    :roles -> principals
    Role2                   :roles2 -> RichesPrincipals
    Users                   :people -> passPrinc
    accounts_CASE           :accounts -> (people -> α) -> α
    accounts_size           :accounts -> num
    num2people              :num -> people
    num2people2             :num -> people2
    num2roles               :num -> roles
    num2roles2              :num -> roles2
    passPrinc_CASE          :passPrinc -> (people -> α) -> α
    passPrinc_size          :passPrinc -> num
    people22num             :people2 -> num
    people2_CASE            :people2 -> α -> α
    people2_size            :people2 -> num
    people2num              :people -> num
    people_CASE             :people -> α -> α
    people_size             :people -> num
    pinIdPrinc_CASE         :pinIdPrinc -> (people2 -> α) -> α
    pinIdPrinc_size         :pinIdPrinc -> num
    principals_CASE         :principals ->
                             (passPrinc -> α) ->
                             (passPrinc -> α) -> (roles -> α) -> α
    principals_size         :principals -> num
    richAccts_CASE          :richAccts -> (pinIdPrinc -> α) -> α
    richAccts_size          :richAccts -> num
    roles22num              :roles2 -> num
    roles2_CASE             :roles2 -> α -> α
    roles2_size             :roles2 -> num
    roles2num               :roles -> num
    roles_CASE              :roles -> α -> α
    roles_size              :roles -> num

Definitions:
    @tempBankOfRiches_def
      |- BankOfRiches = num2roles2 0
    @tempDon_def
      |- Don = num2people2 0
    @tempKennedyCenter_def
      |- KennedyCenter = num2roles 0
    @tempMary_def
      |- Mary = num2people 0
    RichesPrincipals_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'RichesPrincipals' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR 0 (a,ARB,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) (a,ARB,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC (SUC 0)) (a,ARB,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC (SUC (SUC 0)))
                             (ARB,a,ARB) (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC (SUC (SUC (SUC 0))))
                             (ARB,ARB,a) (λn. ind_type$BOTTOM)) a) ⇒
                     'RichesPrincipals' a0) ⇒
                  'RichesPrincipals' a0) rep
    RichesPrincipals_case_def
      |- (∀a f f1 f2 f3 f4.
            RichesPrincipals_CASE (PR2 a) f f1 f2 f3 f4 = f a) ∧
         (∀a f f1 f2 f3 f4.
            RichesPrincipals_CASE (PIN a) f f1 f2 f3 f4 = f1 a) ∧
         (∀a f f1 f2 f3 f4.
            RichesPrincipals_CASE (ID a) f f1 f2 f3 f4 = f2 a) ∧
         (∀a f f1 f2 f3 f4.
            RichesPrincipals_CASE (Role2 a) f f1 f2 f3 f4 = f3 a) ∧
         ∀a f f1 f2 f3 f4.
           RichesPrincipals_CASE (BN a) f f1 f2 f3 f4 = f4 a
    RichesPrincipals_size_def
      |- (∀a. RichesPrincipals_size (PR2 a) = 1 + pinIdPrinc_size a) ∧
         (∀a. RichesPrincipals_size (PIN a) = 1 + pinIdPrinc_size a) ∧
         (∀a. RichesPrincipals_size (ID a) = 1 + pinIdPrinc_size a) ∧
         (∀a. RichesPrincipals_size (Role2 a) = 1 + roles2_size a) ∧
         ∀a. RichesPrincipals_size (BN a) = 1 + a
    accounts_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'accounts' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ⇒
                     'accounts' a0) ⇒
                  'accounts' a0) rep
    accounts_case_def
      |- ∀a f. accounts_CASE (AC a) f = f a
    accounts_size_def
      |- ∀a. accounts_size (AC a) = 1 + people_size a
    passPrinc_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'passPrinc' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ⇒
                     'passPrinc' a0) ⇒
                  'passPrinc' a0) rep
    passPrinc_case_def
      |- ∀a f. passPrinc_CASE (Users a) f = f a
    passPrinc_size_def
      |- ∀a. passPrinc_size (Users a) = 1 + people_size a
    people2_BIJ
      |- (∀a. num2people2 (people22num a) = a) ∧
         ∀r. (λn. n < 1) r ⇔ (people22num (num2people2 r) = r)
    people2_CASE
      |- ∀x v0. (case x of Don => v0) = (λm. v0) (people22num x)
    people2_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 1) rep
    people2_size_def
      |- ∀x. people2_size x = 0
    people_BIJ
      |- (∀a. num2people (people2num a) = a) ∧
         ∀r. (λn. n < 1) r ⇔ (people2num (num2people r) = r)
    people_CASE
      |- ∀x v0. (case x of Mary => v0) = (λm. v0) (people2num x)
    people_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 1) rep
    people_size_def
      |- ∀x. people_size x = 0
    pinIdPrinc_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'pinIdPrinc' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ⇒
                     'pinIdPrinc' a0) ⇒
                  'pinIdPrinc' a0) rep
    pinIdPrinc_case_def
      |- ∀a f. pinIdPrinc_CASE (Client a) f = f a
    pinIdPrinc_size_def
      |- ∀a. pinIdPrinc_size (Client a) = 1 + people2_size a
    principals_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'principals' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR 0 (a,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC 0) (a,ARB)
                             (λn. ind_type$BOTTOM)) a) ∨
                     (∃a.
                        a0 =
                        (λa.
                           ind_type$CONSTR (SUC (SUC 0)) (ARB,a)
                             (λn. ind_type$BOTTOM)) a) ⇒
                     'principals' a0) ⇒
                  'principals' a0) rep
    principals_case_def
      |- (∀a f f1 f2. principals_CASE (PR a) f f1 f2 = f a) ∧
         (∀a f f1 f2. principals_CASE (Pass a) f f1 f2 = f1 a) ∧
         ∀a f f1 f2. principals_CASE (Role a) f f1 f2 = f2 a
    principals_size_def
      |- (∀a. principals_size (PR a) = 1 + passPrinc_size a) ∧
         (∀a. principals_size (Pass a) = 1 + passPrinc_size a) ∧
         ∀a. principals_size (Role a) = 1 + roles_size a
    richAccts_TY_DEF
      |- ∃rep.
           TYPE_DEFINITION
             (λa0.
                ∀'richAccts' .
                  (∀a0.
                     (∃a.
                        a0 =
                        (λa. ind_type$CONSTR 0 a (λn. ind_type$BOTTOM))
                          a) ⇒
                     'richAccts' a0) ⇒
                  'richAccts' a0) rep
    richAccts_case_def
      |- ∀a f. richAccts_CASE (RAC a) f = f a
    richAccts_size_def
      |- ∀a. richAccts_size (RAC a) = 1 + pinIdPrinc_size a
    roles2_BIJ
      |- (∀a. num2roles2 (roles22num a) = a) ∧
         ∀r. (λn. n < 1) r ⇔ (roles22num (num2roles2 r) = r)
    roles2_CASE
      |- ∀x v0. (case x of BankOfRiches => v0) = (λm. v0) (roles22num x)
    roles2_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 1) rep
    roles2_size_def
      |- ∀x. roles2_size x = 0
    roles_BIJ
      |- (∀a. num2roles (roles2num a) = a) ∧
         ∀r. (λn. n < 1) r ⇔ (roles2num (num2roles r) = r)
    roles_CASE
      |- ∀x v0. (case x of KennedyCenter => v0) = (λm. v0) (roles2num x)
    roles_TY_DEF
      |- ∃rep. TYPE_DEFINITION (λn. n < 1) rep
    roles_size_def
      |- ∀x. roles_size x = 0

Theorems:
    RichesPrincipals_11
      |- (∀a a'. (PR2 a = PR2 a') ⇔ (a = a')) ∧
         (∀a a'. (PIN a = PIN a') ⇔ (a = a')) ∧
         (∀a a'. (ID a = ID a') ⇔ (a = a')) ∧
         (∀a a'. (Role2 a = Role2 a') ⇔ (a = a')) ∧
         ∀a a'. (BN a = BN a') ⇔ (a = a')
    RichesPrincipals_Axiom
      |- ∀f0 f1 f2 f3 f4.
           ∃fn.
             (∀a. fn (PR2 a) = f0 a) ∧ (∀a. fn (PIN a) = f1 a) ∧
             (∀a. fn (ID a) = f2 a) ∧ (∀a. fn (Role2 a) = f3 a) ∧
             ∀a. fn (BN a) = f4 a
    RichesPrincipals_case_cong
      |- ∀M M' f f1 f2 f3 f4.
           (M = M') ∧ (∀a. (M' = PR2 a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = PIN a) ⇒ (f1 a = f1' a)) ∧
           (∀a. (M' = ID a) ⇒ (f2 a = f2' a)) ∧
           (∀a. (M' = Role2 a) ⇒ (f3 a = f3' a)) ∧
           (∀a. (M' = BN a) ⇒ (f4 a = f4' a)) ⇒
           (RichesPrincipals_CASE M f f1 f2 f3 f4 =
            RichesPrincipals_CASE M' f' f1' f2' f3' f4')
    RichesPrincipals_distinct
      |- (∀a' a. PR2 a ≠ PIN a') ∧ (∀a' a. PR2 a ≠ ID a') ∧
         (∀a' a. PR2 a ≠ Role2 a') ∧ (∀a' a. PR2 a ≠ BN a') ∧
         (∀a' a. PIN a ≠ ID a') ∧ (∀a' a. PIN a ≠ Role2 a') ∧
         (∀a' a. PIN a ≠ BN a') ∧ (∀a' a. ID a ≠ Role2 a') ∧
         (∀a' a. ID a ≠ BN a') ∧ ∀a' a. Role2 a ≠ BN a'
    RichesPrincipals_induction
      |- ∀P.
           (∀p. P (PR2 p)) ∧ (∀p. P (PIN p)) ∧ (∀p. P (ID p)) ∧
           (∀r. P (Role2 r)) ∧ (∀n. P (BN n)) ⇒
           ∀R. P R
    RichesPrincipals_nchotomy
      |- ∀RR.
           (∃p. RR = PR2 p) ∨ (∃p. RR = PIN p) ∨ (∃p. RR = ID p) ∨
           (∃r. RR = Role2 r) ∨ ∃n. RR = BN n
    accounts_11
      |- ∀a a'. (AC a = AC a') ⇔ (a = a')
    accounts_Axiom
      |- ∀f. ∃fn. ∀a. fn (AC a) = f a
    accounts_case_cong
      |- ∀M M' f.
           (M = M') ∧ (∀a. (M' = AC a) ⇒ (f a = f' a)) ⇒
           (accounts_CASE M f = accounts_CASE M' f')
    accounts_induction
      |- ∀P. (∀p. P (AC p)) ⇒ ∀a. P a
    accounts_nchotomy
      |- ∀aa. ∃p. aa = AC p
    datatype_RichesPrincipals
      |- DATATYPE (RichesPrincipals PR2 PIN ID Role2 BN)
    datatype_accounts
      |- DATATYPE (accounts AC)
    datatype_passPrinc
      |- DATATYPE (passPrinc Users)
    datatype_people
      |- DATATYPE (people Mary)
    datatype_people2
      |- DATATYPE (people2 Don)
    datatype_pinIdPrinc
      |- DATATYPE (pinIdPrinc Client)
    datatype_principals
      |- DATATYPE (principals PR Pass Role)
    datatype_richAccts
      |- DATATYPE (richAccts RAC)
    datatype_roles
      |- DATATYPE (roles KennedyCenter)
    datatype_roles2
      |- DATATYPE (roles2 BankOfRiches)
    exam2_1_thm
       [....] |- (M,Oi,Os) sat prop (AC Mary)
    exam2_2_thm
       [....] |- (M,Oi,Os) sat prop (RAC (Client Don))
    num2people2_11
      |- ∀r r'.
           r < 1 ⇒
           r' < 1 ⇒
           ((num2people2 r = num2people2 r') ⇔ (r = r'))
    num2people2_ONTO
      |- ∀a. ∃r. (a = num2people2 r) ∧ r < 1
    num2people2_people22num
      |- ∀a. num2people2 (people22num a) = a
    num2people2_thm
      |- num2people2 0 = Don
    num2people_11
      |- ∀r r'.
           r < 1 ⇒ r' < 1 ⇒ ((num2people r = num2people r') ⇔ (r = r'))
    num2people_ONTO
      |- ∀a. ∃r. (a = num2people r) ∧ r < 1
    num2people_people2num
      |- ∀a. num2people (people2num a) = a
    num2people_thm
      |- num2people 0 = Mary
    num2roles2_11
      |- ∀r r'.
           r < 1 ⇒ r' < 1 ⇒ ((num2roles2 r = num2roles2 r') ⇔ (r = r'))
    num2roles2_ONTO
      |- ∀a. ∃r. (a = num2roles2 r) ∧ r < 1
    num2roles2_roles22num
      |- ∀a. num2roles2 (roles22num a) = a
    num2roles2_thm
      |- num2roles2 0 = BankOfRiches
    num2roles_11
      |- ∀r r'.
           r < 1 ⇒ r' < 1 ⇒ ((num2roles r = num2roles r') ⇔ (r = r'))
    num2roles_ONTO
      |- ∀a. ∃r. (a = num2roles r) ∧ r < 1
    num2roles_roles2num
      |- ∀a. num2roles (roles2num a) = a
    num2roles_thm
      |- num2roles 0 = KennedyCenter
    passPrinc_11
      |- ∀a a'. (Users a = Users a') ⇔ (a = a')
    passPrinc_Axiom
      |- ∀f. ∃fn. ∀a. fn (Users a) = f a
    passPrinc_case_cong
      |- ∀M M' f.
           (M = M') ∧ (∀a. (M' = Users a) ⇒ (f a = f' a)) ⇒
           (passPrinc_CASE M f = passPrinc_CASE M' f')
    passPrinc_induction
      |- ∀P. (∀p. P (Users p)) ⇒ ∀p. P p
    passPrinc_nchotomy
      |- ∀pp. ∃p. pp = Users p
    people22num_11
      |- ∀a a'. (people22num a = people22num a') ⇔ (a = a')
    people22num_ONTO
      |- ∀r. r < 1 ⇔ ∃a. r = people22num a
    people22num_num2people2
      |- ∀r. r < 1 ⇔ (people22num (num2people2 r) = r)
    people22num_thm
      |- people22num Don = 0
    people2_Axiom
      |- ∀x0. ∃f. f Don = x0
    people2_EQ_people2
      |- ∀a a'. (a = a') ⇔ (people22num a = people22num a')
    people2_case_cong
      |- ∀M M' v0.
           (M = M') ∧ ((M' = Don) ⇒ (v0 = v0')) ⇒
           ((case M of Don => v0) = case M' of Don => v0')
    people2_case_def
      |- ∀v0. (case Don of Don => v0) = v0
    people2_induction
      |- ∀P. P Don ⇒ ∀a. P a
    people2_nchotomy
      |- ∀a. a = Don
    people2num_11
      |- ∀a a'. (people2num a = people2num a') ⇔ (a = a')
    people2num_ONTO
      |- ∀r. r < 1 ⇔ ∃a. r = people2num a
    people2num_num2people
      |- ∀r. r < 1 ⇔ (people2num (num2people r) = r)
    people2num_thm
      |- people2num Mary = 0
    people_Axiom
      |- ∀x0. ∃f. f Mary = x0
    people_EQ_people
      |- ∀a a'. (a = a') ⇔ (people2num a = people2num a')
    people_case_cong
      |- ∀M M' v0.
           (M = M') ∧ ((M' = Mary) ⇒ (v0 = v0')) ⇒
           ((case M of Mary => v0) = case M' of Mary => v0')
    people_case_def
      |- ∀v0. (case Mary of Mary => v0) = v0
    people_induction
      |- ∀P. P Mary ⇒ ∀a. P a
    people_nchotomy
      |- ∀a. a = Mary
    pinIdPrinc_11
      |- ∀a a'. (Client a = Client a') ⇔ (a = a')
    pinIdPrinc_Axiom
      |- ∀f. ∃fn. ∀a. fn (Client a) = f a
    pinIdPrinc_case_cong
      |- ∀M M' f.
           (M = M') ∧ (∀a. (M' = Client a) ⇒ (f a = f' a)) ⇒
           (pinIdPrinc_CASE M f = pinIdPrinc_CASE M' f')
    pinIdPrinc_induction
      |- ∀P. (∀p. P (Client p)) ⇒ ∀p. P p
    pinIdPrinc_nchotomy
      |- ∀pp. ∃p. pp = Client p
    principals_11
      |- (∀a a'. (PR a = PR a') ⇔ (a = a')) ∧
         (∀a a'. (Pass a = Pass a') ⇔ (a = a')) ∧
         ∀a a'. (Role a = Role a') ⇔ (a = a')
    principals_Axiom
      |- ∀f0 f1 f2.
           ∃fn.
             (∀a. fn (PR a) = f0 a) ∧ (∀a. fn (Pass a) = f1 a) ∧
             ∀a. fn (Role a) = f2 a
    principals_case_cong
      |- ∀M M' f f1 f2.
           (M = M') ∧ (∀a. (M' = PR a) ⇒ (f a = f' a)) ∧
           (∀a. (M' = Pass a) ⇒ (f1 a = f1' a)) ∧
           (∀a. (M' = Role a) ⇒ (f2 a = f2' a)) ⇒
           (principals_CASE M f f1 f2 = principals_CASE M' f' f1' f2')
    principals_distinct
      |- (∀a' a. PR a ≠ Pass a') ∧ (∀a' a. PR a ≠ Role a') ∧
         ∀a' a. Pass a ≠ Role a'
    principals_induction
      |- ∀P.
           (∀p. P (PR p)) ∧ (∀p. P (Pass p)) ∧ (∀r. P (Role r)) ⇒
           ∀p. P p
    principals_nchotomy
      |- ∀pp. (∃p. pp = PR p) ∨ (∃p. pp = Pass p) ∨ ∃r. pp = Role r
    richAccts_11
      |- ∀a a'. (RAC a = RAC a') ⇔ (a = a')
    richAccts_Axiom
      |- ∀f. ∃fn. ∀a. fn (RAC a) = f a
    richAccts_case_cong
      |- ∀M M' f.
           (M = M') ∧ (∀a. (M' = RAC a) ⇒ (f a = f' a)) ⇒
           (richAccts_CASE M f = richAccts_CASE M' f')
    richAccts_induction
      |- ∀P. (∀p. P (RAC p)) ⇒ ∀r. P r
    richAccts_nchotomy
      |- ∀rr. ∃p. rr = RAC p
    roles22num_11
      |- ∀a a'. (roles22num a = roles22num a') ⇔ (a = a')
    roles22num_ONTO
      |- ∀r. r < 1 ⇔ ∃a. r = roles22num a
    roles22num_num2roles2
      |- ∀r. r < 1 ⇔ (roles22num (num2roles2 r) = r)
    roles22num_thm
      |- roles22num BankOfRiches = 0
    roles2_Axiom
      |- ∀x0. ∃f. f BankOfRiches = x0
    roles2_EQ_roles2
      |- ∀a a'. (a = a') ⇔ (roles22num a = roles22num a')
    roles2_case_cong
      |- ∀M M' v0.
           (M = M') ∧ ((M' = BankOfRiches) ⇒ (v0 = v0')) ⇒
           ((case M of BankOfRiches => v0) =
            case M' of BankOfRiches => v0')
    roles2_case_def
      |- ∀v0. (case BankOfRiches of BankOfRiches => v0) = v0
    roles2_induction
      |- ∀P. P BankOfRiches ⇒ ∀a. P a
    roles2_nchotomy
      |- ∀a. a = BankOfRiches
    roles2num_11
      |- ∀a a'. (roles2num a = roles2num a') ⇔ (a = a')
    roles2num_ONTO
      |- ∀r. r < 1 ⇔ ∃a. r = roles2num a
    roles2num_num2roles
      |- ∀r. r < 1 ⇔ (roles2num (num2roles r) = r)
    roles2num_thm
      |- roles2num KennedyCenter = 0
    roles_Axiom
      |- ∀x0. ∃f. f KennedyCenter = x0
    roles_EQ_roles
      |- ∀a a'. (a = a') ⇔ (roles2num a = roles2num a')
    roles_case_cong
      |- ∀M M' v0.
           (M = M') ∧ ((M' = KennedyCenter) ⇒ (v0 = v0')) ⇒
           ((case M of KennedyCenter => v0) =
            case M' of KennedyCenter => v0')
    roles_case_def
      |- ∀v0. (case KennedyCenter of KennedyCenter => v0) = v0
    roles_induction
      |- ∀P. P KennedyCenter ⇒ ∀a. P a
    roles_nchotomy
      |- ∀a. a = KennedyCenter
Exporting theory "exam2" ... done.
Theory "exam2" took 0.57789s to build
Completed load of exam2Script
